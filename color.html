<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pixel Art Pro: Masterpiece</title>
    <style>
        :root {
            --bg-color: #f0f4f8;
            --grid-line: #e0e0e0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            margin: 0;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none; /* We handle touches manually */
        }

        /* --- Portrait Lock --- */
        #portrait-warning {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #263238;
            color: white;
            z-index: 9999;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 20px;
        }
        @media screen and (orientation: landscape) {
            #portrait-warning { display: flex; }
        }

        /* --- Header --- */
        header {
            height: 60px;
            background: white;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 20px;
            z-index: 20;
        }

        h1 { margin: 0; font-size: 1.1rem; color: #37474f; font-weight: 700; letter-spacing: 0.5px; }

        .btn-text {
            border: none; background: none; color: #0288d1;
            font-weight: 600; font-size: 0.9rem; cursor: pointer;
        }

        /* --- Canvas Area --- */
        #viewport {
            flex: 1;
            position: relative;
            background-color: #cfd8dc; /* Canvas background */
            overflow: hidden;
            cursor: grab;
        }

        #viewport:active { cursor: grabbing; }

        /* The moving container */
        #canvas-layer {
            position: absolute;
            top: 50%; left: 50%; /* Start centered */
            transform-origin: center center;
            /* We will control transform via JS */
        }

        /* The Grid */
        #grid {
            display: grid;
            /* 32 cols x 20px base size = 640px width */
            width: 640px; 
            grid-template-columns: repeat(32, 1fr);
            background-color: #fff;
            box-shadow: 0 20px 50px rgba(0,0,0,0.3);
            border: 1px solid #ccc;
        }

        .pixel {
            width: 20px; /* Base size */
            height: 20px;
            background-color: white;
            border: 1px solid var(--grid-line);
            box-sizing: border-box;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            color: #ccc;
        }

        .pixel.filled {
            color: transparent;
            border-color: rgba(0,0,0,0.05);
        }
        
        /* Highlight numbers when zoomed in */
        .pixel.filled span { display: none; }

        /* --- Palette (Bottom) --- */
        #bottom-panel {
            height: 90px;
            background: white;
            box-shadow: 0 -5px 20px rgba(0,0,0,0.05);
            z-index: 20;
            display: flex;
            align-items: center;
            padding: 0 15px;
            padding-bottom: 10px; /* Safe area */
        }

        #palette {
            display: flex;
            gap: 15px;
            overflow-x: auto;
            width: 100%;
            padding: 5px;
            -webkit-overflow-scrolling: touch;
        }
        
        .color-btn {
            flex-shrink: 0;
            width: 50px;
            height: 50px;
            border-radius: 12px;
            border: 2px solid #eee;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.1rem;
            color: white;
            text-shadow: 0 1px 1px rgba(0,0,0,0.3);
            transition: transform 0.1s;
        }

        .color-btn.selected {
            transform: scale(1.1) translateY(-5px);
            border: 3px solid #333;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .color-btn.dark-text { color: #444; text-shadow: none; }

        /* --- Win Overlay --- */
        #win-message {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255,255,255,0.95);
            display: none;
            flex-direction: column; align-items: center; justify-content: center;
            z-index: 100; opacity: 0; transition: opacity 0.5s;
        }
        #win-message.visible { opacity: 1; }
        #win-message h2 { font-size: 2.5rem; color: #37474f; }
        .big-btn {
            background: #29b6f6; color: white; padding: 15px 40px;
            font-size: 1.2rem; border-radius: 50px; border:none;
            box-shadow: 0 5px 15px rgba(41, 182, 246, 0.4);
        }

    </style>
</head>
<body>

    <div id="portrait-warning">
        <div style="font-size: 3rem; margin-bottom: 20px">ðŸ“±</div>
        <h3>Please rotate to Portrait</h3>
    </div>

    <header>
        <button class="btn-text" onclick="resetView()">Recenter</button>
        <h1 id="level-title">Detailed Ragdoll</h1>
        <button class="btn-text" onclick="resetLevel()">Reset</button>
    </header>

    <div id="viewport">
        <div id="canvas-layer">
            <div id="grid"></div>
        </div>
    </div>

    <div id="bottom-panel">
        <div id="palette"></div>
    </div>

    <div id="win-message">
        <h2>Masterpiece!</h2>
        <button class="big-btn" onclick="hideWin()">Keep Painting</button>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    <script>
        
        // --- DATA: 32x32 Detailed Ragdoll Cat ---
        const catLevel = {
            name: "Detailed Ragdoll",
            rows: 32,
            cols: 32,
            palette: [
                { id: 1, color: '#4E342E', label: '1' }, // Dark Brown (Ears/Points)
                { id: 2, color: '#FFF8E1', label: '2' }, // Cream (Base Fur)
                { id: 3, color: '#D7CCC8', label: '3' }, // Light Shadow (Fur shading)
                { id: 4, color: '#039BE5', label: '4' }, // Sapphire Blue (Eyes)
                { id: 5, color: '#F48FB1', label: '5' }, // Pink (Nose/Blush)
                { id: 6, color: '#FFFFFF', label: '6' }  // Pure White (Highlights/Whiskers)
            ],
            // Compressed logic to generate the array (to save space)
            // This builds a "Cute Ragdoll" 32x32 shape
            data: [] 
        };

        // --- GENERATE PIXEL DATA ---
        // I am generating the 1024 pixel array programmatically to ensure symmetry and detail
        function generateCatData() {
            let d = new Array(32 * 32).fill(0);
            const set = (r, c, val) => {
                if (r >= 0 && r < 32 && c >= 0 && c < 32) d[r * 32 + c] = val;
            };
            const fillRect = (r1, c1, r2, c2, val) => {
                for(let r=r1; r<=r2; r++) for(let c=c1; c<=c2; c++) set(r,c,val);
            };

            // 1. Base Shape (Fluffy Circle Body)
            // Head Area
            for(let r=4; r<22; r++) {
                for(let c=4; c<28; c++) {
                    // Simple circle math
                    let dx = c - 15.5; let dy = r - 14;
                    if(dx*dx + dy*dy < 90) set(r,c, 2); // Cream Head
                }
            }
            
            // Body Area (Bottom)
            for(let r=18; r<30; r++) {
                for(let c=2; c<30; c++) {
                    let dx = c - 15.5; let dy = r - 22;
                    if(dx*dx*0.7 + dy*dy < 70) set(r,c, 2); // Cream Body
                }
            }

            // 2. Ears (Dark Brown Points)
            // Left Ear
            set(4,6,1); set(5,5,1); set(5,6,1); set(5,7,1); 
            set(6,4,1); set(6,5,1); set(6,6,1); set(6,7,1); set(6,8,1);
            set(7,5,1); set(7,6,1); set(7,7,1); 
            // Right Ear
            set(4,25,1); set(5,24,1); set(5,25,1); set(5,26,1);
            set(6,23,1); set(6,24,1); set(6,25,1); set(6,26,1); set(6,27,1);
            set(7,24,1); set(7,25,1); set(7,26,1);

            // 3. Face Details (The "Mask" shadow)
            for(let r=10; r<18; r++) {
                for(let c=10; c<22; c++) {
                    if(d[r*32+c] === 2) set(r,c, 3); // Light Shadow mask
                }
            }

            // 4. Eyes (Sapphire Blue with White Sparkle)
            // Left Eye
            fillRect(12, 10, 14, 12, 4); // Blue
            set(12, 10, 6); // Sparkle
            // Right Eye
            fillRect(12, 19, 14, 21, 4); // Blue
            set(12, 19, 6); // Sparkle

            // 5. Nose & Mouth (Pink)
            set(16, 15, 5); set(16, 16, 5); 
            set(17, 16, 5); // Tiny nose tip

            // 6. Whiskers (White)
            set(16, 8, 6); set(16, 7, 6);
            set(17, 8, 6); 
            set(16, 23, 6); set(16, 24, 6);
            set(17, 23, 6);

            // 7. Tail (Dark Brown) curving out
            set(25,28,1); set(26,29,1); set(27,29,1); set(28,29,1); set(29,28,1);

            // 8. Paws (White)
            fillRect(28, 12, 29, 14, 6); // Left Paw
            fillRect(28, 17, 29, 19, 6); // Right Paw

            catLevel.data = d;
        }
        generateCatData();

        // --- APP STATE ---
        let selectedColor = 1;
        
        // --- VIEWPORT STATE (Transform) ---
        let state = {
            scale: 1, // Current zoom level
            panning: false,
            pointX: 0,
            pointY: 0,
            startX: 0,
            startY: 0,
            cssX: -320, // Start centered (Grid width 640 / 2)
            cssY: -320  // Start centered
        };

        const viewport = document.getElementById('viewport');
        const canvasLayer = document.getElementById('canvas-layer');
        const gridEl = document.getElementById('grid');
        const paletteEl = document.getElementById('palette');

        // --- INIT ---
        function init() {
            // Build Grid
            gridEl.innerHTML = '';
            catLevel.data.forEach((val, i) => {
                const px = document.createElement('div');
                px.className = 'pixel';
                px.dataset.i = i;
                px.dataset.c = val; // Target color
                if(val === 0) {
                    px.style.opacity = 0; // Invisible background
                    px.style.pointerEvents = 'none';
                } else {
                    px.textContent = val;
                }
                gridEl.appendChild(px);
            });

            // Build Palette
            paletteEl.innerHTML = '';
            catLevel.palette.forEach((p, index) => {
                const btn = document.createElement('div');
                btn.className = 'color-btn';
                if(['#FFF8E1', '#FFFFFF', '#D7CCC8'].includes(p.color)) btn.classList.add('dark-text');
                btn.style.backgroundColor = p.color;
                btn.textContent = p.label;
                btn.onclick = () => selectColorBtn(p.id, btn);
                paletteEl.appendChild(btn);
                if(index === 0) selectColorBtn(p.id, btn);
            });

            // Initial Centering
            resetView();
            
            // Attach Event Listeners
            attachInputHandlers();
        }

        function selectColorBtn(id, btn) {
            selectedColor = id;
            document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('selected'));
            btn.classList.add('selected');
        }

        function resetView() {
            state.scale = 0.8; // Start slightly zoomed out to see whole cat
            state.cssX = 0;
            state.cssY = 0;
            updateTransform();
        }

        function updateTransform() {
            // We use translate3d for hardware acceleration
            canvasLayer.style.transform = `translate3d(${state.cssX}px, ${state.cssY}px, 0px) scale(${state.scale})`;
        }

        // --- INTERACTION ENGINE (The Pinch/Zoom Logic) ---
        function attachInputHandlers() {
            let startDist = 0;
            let startScale = 1;

            // 1. TOUCH EVENTS (iPad/Mobile)
            viewport.addEventListener('touchstart', (e) => {
                // Determine Interaction Type
                if (e.touches.length === 2) {
                    // PINCH START
                    state.panning = false;
                    startDist = Math.hypot(
                        e.touches[0].pageX - e.touches[1].pageX,
                        e.touches[0].pageY - e.touches[1].pageY
                    );
                    startScale = state.scale;
                } else if (e.touches.length === 1) {
                    // PAN START
                    state.panning = true;
                    state.startX = e.touches[0].clientX - state.cssX;
                    state.startY = e.touches[0].clientY - state.cssY;
                }
            }, { passive: false });

            viewport.addEventListener('touchmove', (e) => {
                e.preventDefault(); // Prevent Browser Scroll

                if (e.touches.length === 2) {
                    // PINCH MOVE
                    const dist = Math.hypot(
                        e.touches[0].pageX - e.touches[1].pageX,
                        e.touches[0].pageY - e.touches[1].pageY
                    );
                    // Calculate new scale
                    let newScale = startScale * (dist / startDist);
                    // Clamp scale (0.5x to 4.0x)
                    state.scale = Math.min(Math.max(0.5, newScale), 4);
                    updateTransform();
                } else if (e.touches.length === 1 && state.panning) {
                    // PAN MOVE
                    state.cssX = e.touches[0].clientX - state.startX;
                    state.cssY = e.touches[0].clientY - state.startY;
                    updateTransform();
                }
            }, { passive: false });

            viewport.addEventListener('touchend', () => {
                state.panning = false;
            });

            // 2. MOUSE EVENTS (Desktop/Debugging)
            viewport.addEventListener('mousedown', (e) => {
                state.panning = true;
                state.startX = e.clientX - state.cssX;
                state.startY = e.clientY - state.cssY;
                viewport.style.cursor = 'grabbing';
            });
            window.addEventListener('mousemove', (e) => {
                if (!state.panning) return;
                e.preventDefault();
                state.cssX = e.clientX - state.startX;
                state.cssY = e.clientY - state.startY;
                updateTransform();
            });
            window.addEventListener('mouseup', () => {
                state.panning = false;
                viewport.style.cursor = 'grab';
            });
            // Mouse Wheel Zoom
            viewport.addEventListener('wheel', (e) => {
                e.preventDefault();
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                state.scale = Math.min(Math.max(0.5, state.scale * delta), 4);
                updateTransform();
            }, { passive: false });

            // 3. PAINTING EVENTS (Clicking Pixels)
            // We use event delegation on the Grid
            gridEl.addEventListener('pointerup', (e) => { // pointerup prevents firing while dragging
                // Only paint if we weren't dragging/panning
                if(state.panning) return; 

                const pixel = e.target.closest('.pixel');
                if (!pixel) return;

                const targetColor = parseInt(pixel.dataset.c);
                if (targetColor === selectedColor) {
                    if (!pixel.classList.contains('filled')) {
                        pixel.style.backgroundColor = catLevel.palette.find(c => c.id === targetColor).color;
                        pixel.classList.add('filled');
                        checkWin();
                    }
                } else {
                    // Wiggle animation
                    pixel.animate([
                        { transform: 'translateX(0)' },
                        { transform: 'translateX(5px)' },
                        { transform: 'translateX(-5px)' },
                        { transform: 'translateX(0)' }
                    ], { duration: 200 });
                }
            });
        }

        // --- WIN LOGIC ---
        function checkWin() {
            const filled = document.querySelectorAll('.pixel.filled').length;
            const total = catLevel.data.filter(x => x > 0).length;
            if (filled === total) {
                document.getElementById('win-message').style.display = 'flex';
                setTimeout(() => document.getElementById('win-message').classList.add('visible'), 10);
                confetti({ particleCount: 150, spread: 70, origin: { y: 0.6 } });
            }
        }
        
        function hideWin() {
            document.getElementById('win-message').classList.remove('visible');
            setTimeout(() => document.getElementById('win-message').style.display = 'none', 500);
        }

        function resetLevel() {
            document.querySelectorAll('.pixel').forEach(p => {
                p.classList.remove('filled');
                p.style.backgroundColor = 'white';
            });
        }

        // Start
        init();

    </script>
</body>
</html>
